<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/voiceapp/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/voiceapp/MainActivity.kt" />
              <option name="originalContent" value="package com.example.voiceapp&#10;&#10;import android.os.Bundle&#10;import android.view.Menu&#10;import android.view.View&#10;import android.widget.TextView&#10;import com.google.android.material.snackbar.Snackbar&#10;import com.google.android.material.navigation.NavigationView&#10;import androidx.navigation.findNavController&#10;import androidx.navigation.ui.AppBarConfiguration&#10;import androidx.navigation.ui.navigateUp&#10;import androidx.navigation.ui.setupActionBarWithNavController&#10;import androidx.navigation.ui.setupWithNavController&#10;import androidx.drawerlayout.widget.DrawerLayout&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.example.voiceapp.databinding.ActivityMainBinding&#10;import com.example.voiceapp.ui.settings.SettingsFragment&#10;import android.widget.LinearLayout&#10;&#10;class MainActivity : AppCompatActivity(), com.example.voiceapp.ui.settings.SettingsFragment.OnSettingsSavedListener {&#10;&#10;    private lateinit var appBarConfiguration: AppBarConfiguration&#10;    private lateinit var binding: ActivityMainBinding&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        setSupportActionBar(binding.appBarMain.toolbar)&#10;&#10;//        binding.appBarMain.fab.setOnClickListener { view -&gt;&#10;//            Snackbar.make(view, &quot;Replace with your own action&quot;, Snackbar.LENGTH_LONG)&#10;//                .setAction(&quot;Action&quot;, null)&#10;//                .setAnchorView(R.id.fab).show()&#10;//        }&#10;        val drawerLayout: DrawerLayout = binding.drawerLayout&#10;        val navView: NavigationView = binding.navView&#10;        val navController = findNavController(R.id.nav_host_fragment_content_main)&#10;        // Passing each menu ID as a set of Ids because each&#10;        // menu should be considered as top level destinations.&#10;        appBarConfiguration = AppBarConfiguration(&#10;            setOf(&#10;                R.id.nav_home, R.id.nav_chat, R.id.nav_gallery, R.id.nav_slideshow&#10;            ), drawerLayout&#10;        )&#10;        setupActionBarWithNavController(navController, appBarConfiguration)&#10;        navView.setupWithNavController(navController)&#10;&#10;        // ナビゲーションの遷移リスナーを追加してメニュー選択状態を正しく管理&#10;        navController.addOnDestinationChangedListener { _, destination, _ -&gt;&#10;            // 現在の画面に応じてメニューの選択状態を更新&#10;            when (destination.id) {&#10;                R.id.nav_home -&gt; {&#10;                    navView.setCheckedItem(R.id.nav_home)&#10;                }&#10;                R.id.nav_chat -&gt; {&#10;                    navView.setCheckedItem(R.id.nav_chat)&#10;                }&#10;                R.id.nav_gallery -&gt; {&#10;                    navView.setCheckedItem(R.id.nav_gallery)&#10;                }&#10;                R.id.nav_slideshow -&gt; {&#10;                    navView.setCheckedItem(R.id.nav_slideshow)&#10;                }&#10;                R.id.action_settings -&gt; {&#10;                    // 設定画面では何も選択しない&#10;                    navView.setCheckedItem(View.NO_ID)&#10;                }&#10;            }&#10;            updateNavHeader()&#10;        }&#10;&#10;        menuInflater.inflate(R.menu.main, menu)&#10;        return true&#10;    }&#10;&#10;    override fun onOptionsItemSelected(item: android.view.MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.action_settings -&gt; {&#10;                val navController = findNavController(R.id.nav_host_fragment_content_main)&#10;                navController.navigate(R.id.action_settings)&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    override fun onSupportNavigateUp(): Boolean {&#10;        val navController = findNavController(R.id.nav_host_fragment_content_main)&#10;        return navController.navigateUp(appBarConfiguration) || super.onSupportNavigateUp()&#10;    }&#10;&#10;    override fun onSettingsSaved() {&#10;        updateNavHeader()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.voiceapp&#10;&#10;import android.os.Bundle&#10;import android.view.Menu&#10;import android.view.View&#10;import android.widget.TextView&#10;import com.google.android.material.snackbar.Snackbar&#10;import com.google.android.material.navigation.NavigationView&#10;import androidx.navigation.findNavController&#10;import androidx.navigation.ui.AppBarConfiguration&#10;import androidx.navigation.ui.navigateUp&#10;import androidx.navigation.ui.setupActionBarWithNavController&#10;import androidx.navigation.ui.setupWithNavController&#10;import androidx.drawerlayout.widget.DrawerLayout&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.example.voiceapp.databinding.ActivityMainBinding&#10;import com.example.voiceapp.ui.settings.SettingsFragment&#10;import android.widget.LinearLayout&#10;&#10;class MainActivity : AppCompatActivity(), com.example.voiceapp.ui.settings.SettingsFragment.OnSettingsSavedListener {&#10;&#10;    private lateinit var appBarConfiguration: AppBarConfiguration&#10;    private lateinit var binding: ActivityMainBinding&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        setSupportActionBar(binding.appBarMain.toolbar)&#10;&#10;//        binding.appBarMain.fab.setOnClickListener { view -&gt;&#10;//            Snackbar.make(view, &quot;Replace with your own action&quot;, Snackbar.LENGTH_LONG)&#10;//                .setAction(&quot;Action&quot;, null)&#10;//                .setAnchorView(R.id.fab).show()&#10;//        }&#10;        val drawerLayout: DrawerLayout = binding.drawerLayout&#10;        val navView: NavigationView = binding.navView&#10;        val navController = findNavController(R.id.nav_host_fragment_content_main)&#10;        // Passing each menu ID as a set of Ids because each&#10;        // menu should be considered as top level destinations.&#10;        appBarConfiguration = AppBarConfiguration(&#10;            setOf(&#10;                R.id.nav_home, R.id.nav_chat, R.id.nav_gallery, R.id.nav_slideshow&#10;            ), drawerLayout&#10;        )&#10;        setupActionBarWithNavController(navController, appBarConfiguration)&#10;        navView.setupWithNavController(navController)&#10;&#10;        // ナビゲーションの遷移リスナーを追加してメニュー選択状態を正しく管理&#10;        navController.addOnDestinationChangedListener { _, destination, _ -&gt;&#10;            // 現在の画面に応じてメニューの選択状態を更新&#10;            when (destination.id) {&#10;                R.id.nav_home -&gt; {&#10;                    navView.setCheckedItem(R.id.nav_home)&#10;                }&#10;                R.id.nav_chat -&gt; {&#10;                    navView.setCheckedItem(R.id.nav_chat)&#10;                }&#10;                R.id.nav_gallery -&gt; {&#10;                    navView.setCheckedItem(R.id.nav_gallery)&#10;                }&#10;                R.id.nav_slideshow -&gt; {&#10;                    navView.setCheckedItem(R.id.nav_slideshow)&#10;                }&#10;                R.id.action_settings -&gt; {&#10;                    // 設定画面では何も選択しない&#10;                    navView.setCheckedItem(View.NO_ID)&#10;                }&#10;            }&#10;            updateNavHeader()&#10;        }&#10;&#10;        // ナビゲーションメニューのクリックリスナーを追加&#10;        navView.setNavigationItemSelectedListener { menuItem -&gt;&#10;            when (menuItem.itemId) {&#10;                R.id.nav_home -&gt; {&#10;                    // homeへの確実な遷移処理&#10;                    if (navController.currentDestination?.id != R.id.nav_home) {&#10;                        navController.popBackStack(R.id.nav_home, false) &#10;                        if (navController.currentDestination?.id != R.id.nav_home) {&#10;                            navController.navigate(R.id.nav_home)&#10;                        }&#10;                    }&#10;                    binding.drawerLayout.closeDrawers()&#10;                    true&#10;                }&#10;                R.id.nav_chat -&gt; {&#10;                    if (navController.currentDestination?.id != R.id.nav_chat) {&#10;                        navController.navigate(R.id.nav_chat)&#10;                    }&#10;                    binding.drawerLayout.closeDrawers()&#10;                    true&#10;                }&#10;                R.id.nav_gallery -&gt; {&#10;                    if (navController.currentDestination?.id != R.id.nav_gallery) {&#10;                        navController.navigate(R.id.nav_gallery)&#10;                    }&#10;                    binding.drawerLayout.closeDrawers()&#10;                    true&#10;                }&#10;                R.id.nav_slideshow -&gt; {&#10;                    if (navController.currentDestination?.id != R.id.nav_slideshow) {&#10;                        navController.navigate(R.id.nav_slideshow)&#10;                    }&#10;                    binding.drawerLayout.closeDrawers()&#10;                    true&#10;                }&#10;                R.id.action_settings -&gt; {&#10;                    navController.navigate(R.id.action_settings)&#10;                    binding.drawerLayout.closeDrawers()&#10;                    true&#10;                }&#10;                else -&gt; false&#10;            }&#10;        }&#10;&#10;        // 初期状態でhomeを選択状態にする&#10;        navView.setCheckedItem(R.id.nav_home)&#10;        updateNavHeader()&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        updateNavHeader()&#10;    }&#10;&#10;    private fun updateNavHeader() {&#10;        val navView: NavigationView = binding.navView&#10;        val headerView = navView.getHeaderView(0)&#10;        val userName = SettingsFragment.getUserName(this)&#10;        val agentName = SettingsFragment.getAgentName(this)&#10;&#10;        // ナビゲーションヘッダーのクリック機能を修正&#10;        val headerContainer = headerView.findViewById&lt;LinearLayout&gt;(R.id.nav_header_container)&#10;        headerContainer?.setOnClickListener {&#10;            val navController = findNavController(R.id.nav_host_fragment_content_main)&#10;            // home画面がBackStack上に無い場合も含めて必ずhomeへ遷移&#10;            if (!navController.popBackStack(R.id.nav_home, false)) {&#10;                navController.navigate(R.id.nav_home)&#10;            }&#10;            binding.drawerLayout.closeDrawers() // ドロワーを閉じる&#10;        }&#10;&#10;        // id指定ではなく2番目のTextViewを取得&#10;        val titleTextView = headerView.findViewById&lt;TextView&gt;(R.id.nav_header_title)&#10;            ?: headerView.findViewById&lt;TextView&gt;(android.R.id.text1)&#10;            ?: headerView.findViewById&lt;TextView&gt;(headerView.resources.getIdentifier(&quot;nav_header_title&quot;, &quot;id&quot;, packageName))&#10;            ?: headerView.findViewById&lt;TextView&gt;(headerView.resources.getIdentifier(&quot;title&quot;, &quot;id&quot;, packageName))&#10;            ?: headerView.findViewById&lt;TextView&gt;(headerView.resources.getIdentifier(&quot;textView&quot;, &quot;id&quot;, packageName))&#10;            ?: (headerView as? LinearLayout)?.getChildAt(1) as? TextView&#10;        titleTextView?.text = &quot;$userName さん&quot;&#10;&#10;        // nav_chatメニュータイトルを動的に変更&#10;        val menu = navView.menu&#10;        val chatMenuItem = menu.findItem(R.id.nav_chat)&#10;        chatMenuItem?.title = &quot;$agentName と会話&quot;&#10;    }&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu): Boolean {&#10;        // Inflate the menu; this adds items to the action bar if it is present.&#10;        menuInflater.inflate(R.menu.main, menu)&#10;        return true&#10;    }&#10;&#10;    override fun onOptionsItemSelected(item: android.view.MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.action_settings -&gt; {&#10;                val navController = findNavController(R.id.nav_host_fragment_content_main)&#10;                navController.navigate(R.id.action_settings)&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    override fun onSupportNavigateUp(): Boolean {&#10;        val navController = findNavController(R.id.nav_host_fragment_content_main)&#10;        return navController.navigateUp(appBarConfiguration) || super.onSupportNavigateUp()&#10;    }&#10;&#10;    override fun onSettingsSaved() {&#10;        updateNavHeader()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/voiceapp/ui/chat/ChatViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/voiceapp/ui/chat/ChatViewModel.kt" />
              <option name="originalContent" value="package com.example.voiceapp.ui.chat&#10;&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.voiceapp.BuildConfig&#10;import com.example.voiceapp.api.Message&#10;import com.example.voiceapp.api.OpenAIClient&#10;import kotlinx.coroutines.launch&#10;&#10;data class ChatMessage(&#10;    val content: String,&#10;    val isUser: Boolean,&#10;    val timestamp: Long = System.currentTimeMillis()&#10;)&#10;&#10;class ChatViewModel : ViewModel() {&#10;&#10;    private val _messages = MutableLiveData&lt;List&lt;ChatMessage&gt;&gt;()&#10;    val messages: LiveData&lt;List&lt;ChatMessage&gt;&gt; = _messages&#10;&#10;    private val _isLoading = MutableLiveData&lt;Boolean&gt;()&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#10;&#10;    private val _error = MutableLiveData&lt;String?&gt;()&#10;    val error: LiveData&lt;String?&gt; = _error&#10;&#10;    private val _isApiKeyConfigured = MutableLiveData&lt;Boolean&gt;()&#10;    val isApiKeyConfigured: LiveData&lt;Boolean&gt; = _isApiKeyConfigured&#10;&#10;    private var openAIClient: OpenAIClient? = null&#10;&#10;    init {&#10;        _messages.value = emptyList()&#10;        _isLoading.value = false&#10;        initializeApiKey()&#10;    }&#10;&#10;    private fun initializeApiKey() {&#10;        val apiKey = BuildConfig.OPENAI_API_KEY&#10;            _isApiKeyConfigured.value = true&#10;            openAIClient = OpenAIClient(apiKey)&#10;            _isApiKeyConfigured.value = false&#10;            _error.value = &quot;local.propertiesファイルでOPENAI_API_KEYを設定してください&quot;&#10;        }&#10;    }&#10;&#10;    fun sendMessage(userMessage: String) {&#10;        if (userMessage.isBlank()) return&#10;&#10;        val client = openAIClient&#10;        if (client == null) {&#10;            _error.value = &quot;APIキーが設定されていません&quot;&#10;            return&#10;        }&#10;&#10;        // ユーザーメッセージを追加&#10;        val currentMessages = _messages.value?.toMutableList() ?: mutableListOf()&#10;        currentMessages.add(ChatMessage(userMessage, true))&#10;        _messages.value = currentMessages&#10;&#10;        _isLoading.value = true&#10;        _error.value = null&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // OpenAI APIに送信するメッセージリストを作成&#10;                val apiMessages = currentMessages.map { chatMessage -&gt;&#10;                    Message(&#10;                        role = if (chatMessage.isUser) &quot;user&quot; else &quot;assistant&quot;,&#10;                        content = chatMessage.content&#10;                    )&#10;                }&#10;&#10;                val result = client.sendMessage(apiMessages)&#10;&#10;                result.fold(&#10;                    onSuccess = { response -&gt;&#10;                        val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()&#10;                        updatedMessages.add(ChatMessage(response, false))&#10;                        _messages.value = updatedMessages&#10;                    },&#10;                    onFailure = { exception -&gt;&#10;                        _error.value = &quot;エラー: ${exception.message}&quot;&#10;                    }&#10;                )&#10;            } catch (e: Exception) {&#10;                _error.value = &quot;予期しないエラーが発生しました: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearChat() {&#10;        _messages.value = emptyList()&#10;        _error.value = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.voiceapp.ui.chat&#10;&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.voiceapp.BuildConfig&#10;import com.example.voiceapp.api.Message&#10;import com.example.voiceapp.api.OpenAIClient&#10;import kotlinx.coroutines.launch&#10;&#10;data class ChatMessage(&#10;    val content: String,&#10;    val isUser: Boolean,&#10;    val timestamp: Long = System.currentTimeMillis()&#10;)&#10;&#10;class ChatViewModel : ViewModel() {&#10;&#10;    private val _messages = MutableLiveData&lt;List&lt;ChatMessage&gt;&gt;()&#10;    val messages: LiveData&lt;List&lt;ChatMessage&gt;&gt; = _messages&#10;&#10;    private val _isLoading = MutableLiveData&lt;Boolean&gt;()&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#10;&#10;    private val _error = MutableLiveData&lt;String?&gt;()&#10;    val error: LiveData&lt;String?&gt; = _error&#10;&#10;    private val _isApiKeyConfigured = MutableLiveData&lt;Boolean&gt;()&#10;    val isApiKeyConfigured: LiveData&lt;Boolean&gt; = _isApiKeyConfigured&#10;&#10;    private var openAIClient: OpenAIClient? = null&#10;&#10;    init {&#10;        _messages.value = emptyList()&#10;        _isLoading.value = false&#10;        initializeApiKey()&#10;    }&#10;&#10;    private fun initializeApiKey() {&#10;        val apiKey = BuildConfig.OPENAI_API_KEY&#10;        val baseUrl = BuildConfig.OPENAI_BASE_URL&#10;&#10;        if (apiKey.isNotEmpty() &amp;&amp; apiKey != &quot;your_openai_api_key_here&quot;) {&#10;            openAIClient = OpenAIClient(apiKey, baseUrl)&#10;            _isApiKeyConfigured.value = true&#10;        } else {&#10;            _isApiKeyConfigured.value = false&#10;            _error.value = &quot;local.propertiesファイルでOPENAI_API_KEYを設定してください&quot;&#10;        }&#10;    }&#10;&#10;    fun sendMessage(userMessage: String) {&#10;        if (userMessage.isBlank()) return&#10;&#10;        val client = openAIClient&#10;        if (client == null) {&#10;            _error.value = &quot;APIキーが設定されていません&quot;&#10;            return&#10;        }&#10;&#10;        // ユーザーメッセージを追加&#10;        val currentMessages = _messages.value?.toMutableList() ?: mutableListOf()&#10;        currentMessages.add(ChatMessage(userMessage, true))&#10;        _messages.value = currentMessages&#10;&#10;        _isLoading.value = true&#10;        _error.value = null&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // OpenAI APIに送信するメッセージリストを作成&#10;                val apiMessages = currentMessages.map { chatMessage -&gt;&#10;                    Message(&#10;                        role = if (chatMessage.isUser) &quot;user&quot; else &quot;assistant&quot;,&#10;                        content = chatMessage.content&#10;                    )&#10;                }&#10;&#10;                val result = client.sendMessage(apiMessages)&#10;&#10;                result.fold(&#10;                    onSuccess = { response -&gt;&#10;                        val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()&#10;                        updatedMessages.add(ChatMessage(response, false))&#10;                        _messages.value = updatedMessages&#10;                    },&#10;                    onFailure = { exception -&gt;&#10;                        _error.value = &quot;エラー: ${exception.message}&quot;&#10;                    }&#10;                )&#10;            } catch (e: Exception) {&#10;                _error.value = &quot;予期しないエラーが発生しました: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearChat() {&#10;        _messages.value = emptyList()&#10;        _error.value = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/voiceapp/ui/settings/SettingsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/voiceapp/ui/settings/SettingsFragment.kt" />
              <option name="originalContent" value="package com.example.voiceapp.ui.settings&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import com.example.voiceapp.BuildConfig&#10;import com.example.voiceapp.databinding.FragmentSettingsBinding&#10;&#10;class SettingsFragment : Fragment() {&#10;&#10;    private var _binding: FragmentSettingsBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var sharedPreferences: SharedPreferences&#10;&#10;    companion object {&#10;        private const val PREFS_NAME = &quot;user_settings&quot;&#10;        private const val KEY_USER_NAME = &quot;user_name&quot;&#10;        private const val KEY_AGENT_NAME = &quot;agent_name&quot;&#10;&#10;        // デフォルト値&#10;        const val DEFAULT_USER_NAME = &quot;ユーザー&quot;&#10;        const val DEFAULT_AGENT_NAME = &quot;AIアシスタント&quot;&#10;&#10;        fun getUserName(context: Context): String {&#10;            val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;            return prefs.getString(KEY_USER_NAME, DEFAULT_USER_NAME) ?: DEFAULT_USER_NAME&#10;        }&#10;&#10;        fun getAgentName(context: Context): String {&#10;            val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;            return prefs.getString(KEY_AGENT_NAME, DEFAULT_AGENT_NAME) ?: DEFAULT_AGENT_NAME&#10;        }&#10;    }&#10;&#10;    interface OnSettingsSavedListener {&#10;        fun onSettingsSaved()&#10;    }&#10;    private var settingsSavedListener: OnSettingsSavedListener? = null&#10;&#10;    override fun onAttach(context: Context) {&#10;        super.onAttach(context)&#10;        if (context is OnSettingsSavedListener) {&#10;            settingsSavedListener = context&#10;        }&#10;    }&#10;&#10;    override fun onDetach() {&#10;        super.onDetach()&#10;        settingsSavedListener = null&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentSettingsBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        sharedPreferences = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;//        setupUI()&#10;//        setupUI()&#10;//        setupClickListeners()&#10;//        setupClickListeners()&#10;    }&#10;&#10;//    private fun setupUI() {&#10;//        // APIキーの状態を表示&#10;//        val apiKey = BuildConfig.OPENAI_API_KEY&#10;//        if (apiKey.isNotEmpty() &amp;&amp; apiKey != &quot;your_openai_api_key_here&quot;) {&#10;//            binding.tvApiKeyStatus.text = &quot;APIキー: 設定済み (${apiKey.take(10)}...)&quot;&#10;//        } else {&#10;//            binding.tvApiKeyStatus.text = &quot;APIキー: 未設定&quot;&#10;//        }&#10;//&#10;//        // Base URLを表示&#10;//        binding.tvBaseUrlStatus.text = &quot;Base URL: ${BuildConfig.OPENAI_BASE_URL}&quot;&#10;//    }&#10;&#10;    private fun loadUserSettings() {&#10;        // 保存された設定を読み込み&#10;        val userName = sharedPreferences.getString(KEY_USER_NAME, DEFAULT_USER_NAME)&#10;        val agentName = sharedPreferences.getString(KEY_AGENT_NAME, DEFAULT_AGENT_NAME)&#10;&#10;        binding.etUserName.setText(userName)&#10;        binding.etAgentName.setText(agentName)&#10;//&#10;//    private fun setupClickListeners() {&#10;//        binding.btnSaveUserSettings.setOnClickListener {&#10;//            saveUserSettings()&#10;//        }&#10;    }&#10;//        binding.btnClearCache.setOnClickListener {&#10;//            // チャット履歴クリア機能（後で実装）&#10;//            Toast.makeText(context, &quot;チャット履歴をクリアしました&quot;, Toast.LENGTH_SHORT).show()&#10;//        }&#10;//&#10;//        binding.btnAbout.setOnClickListener {&#10;//            Toast.makeText(context, &quot;Voice App v1.0\nOpenAI互換API対応nav_chatにはfragment_settings.xmlで設定したagent名を表示させてくださいチャットアプリ&quot;, Toast.LENGTH_LONG).show()&#10;//        }&#10;//    }&#10;&#10;//        binding.btnClearCache.setOnClickListener {&#10;//            // チャット履歴クリア機能（後で実装）&#10;//            Toast.makeText(context, &quot;チャット履歴をクリアしました&quot;, Toast.LENGTH_SHORT).show()&#10;//        }&#10;//&#10;//        binding.btnAbout.setOnClickListener {&#10;//            Toast.makeText(context, &quot;Voice App v1.0\nOpenAI互換API対応nav_chatにはfragment_settings.xmlで設定したagent名を表示させてくださいチャットアプリ&quot;, Toast.LENGTH_LONG).show()&#10;//        }&#10;//    }&#10;&#10;    private fun saveUserSettings() {&#10;        val userName = binding.etUserName.text.toString().trim()&#10;        val agentName = binding.etAgentName.text.toString().trim()&#10;&#10;        // 空の場合はデフォルト値を使用&#10;        val finalUserName = if (userName.isEmpty()) DEFAULT_USER_NAME else userName&#10;        val finalAgentName = if (agentName.isEmpty()) DEFAULT_AGENT_NAME else agentName&#10;&#10;        // SharedPreferencesに保存&#10;        sharedPreferences.edit()&#10;            .putString(KEY_USER_NAME, finalUserName)&#10;            .putString(KEY_AGENT_NAME, finalAgentName)&#10;            .apply()&#10;&#10;        // UIを更新&#10;        binding.etUserName.setText(finalUserName)&#10;        binding.etAgentName.setText(finalAgentName)&#10;&#10;        Toast.makeText(context, &quot;設定を保存しました&quot;, Toast.LENGTH_SHORT).show()&#10;        settingsSavedListener?.onSettingsSaved()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.voiceapp.ui.settings&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import com.example.voiceapp.BuildConfig&#10;import com.example.voiceapp.databinding.FragmentSettingsBinding&#10;&#10;class SettingsFragment : Fragment() {&#10;&#10;    private var _binding: FragmentSettingsBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var sharedPreferences: SharedPreferences&#10;&#10;    companion object {&#10;        private const val PREFS_NAME = &quot;user_settings&quot;&#10;        private const val KEY_USER_NAME = &quot;user_name&quot;&#10;        private const val KEY_AGENT_NAME = &quot;agent_name&quot;&#10;&#10;        // デフォルト値&#10;        const val DEFAULT_USER_NAME = &quot;ユーザー&quot;&#10;        const val DEFAULT_AGENT_NAME = &quot;AIアシスタント&quot;&#10;&#10;        fun getUserName(context: Context): String {&#10;            val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;            return prefs.getString(KEY_USER_NAME, DEFAULT_USER_NAME) ?: DEFAULT_USER_NAME&#10;        }&#10;&#10;        fun getAgentName(context: Context): String {&#10;            val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;            return prefs.getString(KEY_AGENT_NAME, DEFAULT_AGENT_NAME) ?: DEFAULT_AGENT_NAME&#10;        }&#10;    }&#10;&#10;    interface OnSettingsSavedListener {&#10;        fun onSettingsSaved()&#10;    }&#10;    private var settingsSavedListener: OnSettingsSavedListener? = null&#10;&#10;    override fun onAttach(context: Context) {&#10;        super.onAttach(context)&#10;        if (context is OnSettingsSavedListener) {&#10;            settingsSavedListener = context&#10;        }&#10;    }&#10;&#10;    override fun onDetach() {&#10;        super.onDetach()&#10;        settingsSavedListener = null&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentSettingsBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        sharedPreferences = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;        loadUserSettings()&#10;        setupClickListeners()&#10;    }&#10;&#10;//    private fun setupUI() {&#10;//        // APIキーの状態を表示&#10;//        val apiKey = BuildConfig.OPENAI_API_KEY&#10;//        if (apiKey.isNotEmpty() &amp;&amp; apiKey != &quot;your_openai_api_key_here&quot;) {&#10;//            binding.tvApiKeyStatus.text = &quot;APIキー: 設定済み (${apiKey.take(10)}...)&quot;&#10;//        } else {&#10;//            binding.tvApiKeyStatus.text = &quot;APIキー: 未設定&quot;&#10;//        }&#10;//&#10;//        // Base URLを表示&#10;//        binding.tvBaseUrlStatus.text = &quot;Base URL: ${BuildConfig.OPENAI_BASE_URL}&quot;&#10;//    }&#10;&#10;    private fun loadUserSettings() {&#10;        // 保存された設定を読み込み&#10;        val userName = sharedPreferences.getString(KEY_USER_NAME, DEFAULT_USER_NAME)&#10;        val agentName = sharedPreferences.getString(KEY_AGENT_NAME, DEFAULT_AGENT_NAME)&#10;&#10;        binding.etUserName.setText(userName)&#10;        binding.etAgentName.setText(agentName)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.btnSaveUserSettings.setOnClickListener {&#10;            saveUserSettings()&#10;        }&#10;    }&#10;&#10;    private fun saveUserSettings() {&#10;        val userName = binding.etUserName.text.toString().trim()&#10;        val agentName = binding.etAgentName.text.toString().trim()&#10;&#10;        // 空の場合はデフォルト値を使用&#10;        val finalUserName = if (userName.isEmpty()) DEFAULT_USER_NAME else userName&#10;        val finalAgentName = if (agentName.isEmpty()) DEFAULT_AGENT_NAME else agentName&#10;&#10;        // SharedPreferencesに保存&#10;        sharedPreferences.edit()&#10;            .putString(KEY_USER_NAME, finalUserName)&#10;            .putString(KEY_AGENT_NAME, finalAgentName)&#10;            .apply()&#10;&#10;        // UIを更新&#10;        binding.etUserName.setText(finalUserName)&#10;        binding.etAgentName.setText(finalAgentName)&#10;&#10;        Toast.makeText(context, &quot;設定を保存しました&quot;, Toast.LENGTH_SHORT).show()&#10;        settingsSavedListener?.onSettingsSaved()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/badge_error.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/badge_error.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &lt;solid android:color=&quot;#F44336&quot; /&gt;&#10;    &lt;corners android:radius=&quot;12dp&quot; /&gt;&#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/badge_success.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/badge_success.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &lt;solid android:color=&quot;#4CAF50&quot; /&gt;&#10;    &lt;corners android:radius=&quot;12dp&quot; /&gt;&#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/badge_warning.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/badge_warning.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &lt;solid android:color=&quot;#FF9800&quot; /&gt;&#10;    &lt;corners android:radius=&quot;12dp&quot; /&gt;&#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_home.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_home.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorOnSurface&quot;&gt;&#10;    &#10;    &lt;!-- 家の屋根 --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/black&quot;&#10;        android:pathData=&quot;M10,20v-6h4v6h5v-8h3L12,3 2,12h3v8z&quot;/&gt;&#10;        &#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_home_detailed.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_home_detailed.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorPrimary&quot;&gt;&#10;    &#10;    &lt;!-- 家の本体 --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/black&quot;&#10;        android:pathData=&quot;M3,12l2,0l0,8l6,0l0,-6l2,0l0,6l6,0l0,-8l2,0l-9,-9z&quot;/&gt;&#10;    &#10;    &lt;!-- ドア --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/white&quot;&#10;        android:pathData=&quot;M11,16l2,0l0,4l-2,0z&quot;/&gt;&#10;        &#10;    &lt;!-- 窓 --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/white&quot;&#10;        android:pathData=&quot;M7,14l1.5,0l0,1.5l-1.5,0z&quot;/&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/white&quot;&#10;        android:pathData=&quot;M15.5,14l1.5,0l0,1.5l-1.5,0z&quot;/&gt;&#10;        &#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>